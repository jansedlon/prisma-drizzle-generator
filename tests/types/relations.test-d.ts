import { expectType, expectError, expectAssignable } from 'tsd';
import { InferSelectModel, InferInsertModel } from 'drizzle-orm';
import { eq, and } from 'drizzle-orm';
import type { PgDatabase } from 'drizzle-orm/pg-core';

// Import generated schemas and relations (these would be generated by the generator)
import { user, post, comment, userProfile } from '../fixtures/generated/schemas';

// Mock database instance for testing
declare const db: PgDatabase<any>;

describe('Type Tests - Relations', () => {

  describe('Inferred Types', () => {
    it('should infer correct select types from schemas', () => {
      type UserSelect = InferSelectModel<typeof user>;
      type PostSelect = InferSelectModel<typeof post>;
      type CommentSelect = InferSelectModel<typeof comment>;

      // User should have all expected fields
      expectType<{
        id: string;
        email: string;
        name: string | null;
        createdAt: Date;
        updatedAt: Date;
      }>({} as UserSelect);

      // Post should have all expected fields including foreign keys
      expectType<{
        id: string;
        title: string;
        content: string | null;
        authorId: string;
        published: boolean;
        createdAt: Date;
        updatedAt: Date;
      }>({} as PostSelect);
    });

    it('should infer correct insert types from schemas', () => {
      type UserInsert = InferInsertModel<typeof user>;
      type PostInsert = InferInsertModel<typeof post>;

      // User insert should have optional auto-generated fields
      expectType<{
        id?: string;
        email: string;
        name?: string | null;
        createdAt?: Date;
        updatedAt?: Date;
      }>({} as UserInsert);

      // Post insert should require foreign keys
      expectType<{
        id?: string;
        title: string;
        content?: string | null;
        authorId: string;  // Required FK
        published?: boolean;
        createdAt?: Date;
        updatedAt?: Date;
      }>({} as PostInsert);
    });
  });

  describe('Query Builder Type Safety', () => {
    it('should provide type-safe queries with relations', async () => {
      // Basic query with relations should be typed
      const userWithPosts = await db
        .select()
        .from(user)
        .leftJoin(post, eq(post.authorId, user.id));

      expectType<Array<{
        user: InferSelectModel<typeof user>;
        post: InferSelectModel<typeof post> | null;
      }>>(userWithPosts);
    });

    it('should enforce correct join conditions', () => {
      // Valid join condition
      expectAssignable<any>(
        db.select().from(user).leftJoin(post, eq(post.authorId, user.id))
      );

      // Invalid join condition should cause type error
      expectError(
        db.select().from(user).leftJoin(post, eq(post.id, user.email))
      );
    });

    it('should provide correct types for nested queries', async () => {
      const postsWithAuthorAndComments = await db
        .select({
          postId: post.id,
          postTitle: post.title,
          authorName: user.name,
          authorEmail: user.email,
        })
        .from(post)
        .leftJoin(user, eq(post.authorId, user.id))
        .leftJoin(comment, eq(comment.postId, post.id));

      expectType<Array<{
        postId: string;
        postTitle: string;
        authorName: string | null;
        authorEmail: string;
      }>>(postsWithAuthorAndComments);
    });
  });

  describe('Relation Query Type Safety', () => {
    it('should type one-to-many relation queries correctly', async () => {
      // User with their posts
      const userWithPosts = await db.query.user.findFirst({
        with: {
          posts: true
        }
      });

      expectType<{
        id: string;
        email: string;
        name: string | null;
        createdAt: Date;
        updatedAt: Date;
        posts: Array<{
          id: string;
          title: string;
          content: string | null;
          authorId: string;
          published: boolean;
          createdAt: Date;
          updatedAt: Date;
        }>;
      } | undefined>(userWithPosts);
    });

    it('should type one-to-one relation queries correctly', async () => {
      // User with their profile
      const userWithProfile = await db.query.user.findFirst({
        with: {
          profile: true
        }
      });

      expectType<{
        id: string;
        email: string;
        name: string | null;
        createdAt: Date;
        updatedAt: Date;
        profile: {
          id: string;
          bio: string | null;
          avatar: string | null;
          userId: string;
          createdAt: Date;
          updatedAt: Date;
        } | null;
      } | undefined>(userWithProfile);
    });

    it('should type many-to-many relation queries correctly', async () => {
      // User with their tags
      const userWithTags = await db.query.user.findFirst({
        with: {
          tags: true
        }
      });

      expectType<{
        id: string;
        email: string;
        name: string | null;
        createdAt: Date;
        updatedAt: Date;
        tags: Array<{
          id: string;
          name: string;
          createdAt: Date;
          updatedAt: Date;
        }>;
      } | undefined>(userWithTags);
    });

    it('should type nested relation queries correctly', async () => {
      // User with posts and their comments
      const userWithPostsAndComments = await db.query.user.findFirst({
        with: {
          posts: {
            with: {
              comments: true
            }
          }
        }
      });

      expectType<{
        id: string;
        email: string;
        name: string | null;
        createdAt: Date;
        updatedAt: Date;
        posts: Array<{
          id: string;
          title: string;
          content: string | null;
          authorId: string;
          published: boolean;
          createdAt: Date;
          updatedAt: Date;
          comments: Array<{
            id: string;
            content: string;
            authorId: string;
            postId: string;
            createdAt: Date;
            updatedAt: Date;
          }>;
        }>;
      } | undefined>(userWithPostsAndComments);
    });
  });

  describe('Relation Constraints', () => {
    it('should enforce foreign key constraints in types', () => {
      // Valid post creation with existing user ID
      expectAssignable<InferInsertModel<typeof post>>({
        title: 'Test Post',
        content: 'Content',
        authorId: 'user-123'  // Must be a valid user ID
      });

      // Should require authorId for post creation
      expectError<InferInsertModel<typeof post>>({
        title: 'Test Post',
        content: 'Content'
        // Missing authorId
      });
    });

    it('should type relation field constraints correctly', () => {
      // UserProfile should require userId
      expectType<{
        id?: string;
        bio?: string | null;
        avatar?: string | null;
        userId: string;  // Required FK
        createdAt?: Date;
        updatedAt?: Date;
      }>({} as InferInsertModel<typeof userProfile>);

      // Should not allow creating profile without userId
      expectError<InferInsertModel<typeof userProfile>>({
        bio: 'Test bio'
        // Missing userId
      });
    });
  });

  describe('Self-Referencing Relations', () => {
    it('should type self-referencing relations correctly', async () => {
      // Assuming Category has self-referencing parent/children
      const categoryWithChildren = await db.query.category.findFirst({
        with: {
          children: {
            with: {
              children: true  // Nested self-reference
            }
          }
        }
      });

      // Type should be recursive
      expectType<{
        id: string;
        name: string;
        parentId: string | null;
        children: Array<{
          id: string;
          name: string;
          parentId: string | null;
          children: Array<{
            id: string;
            name: string;
            parentId: string | null;
          }>;
        }>;
      } | undefined>(categoryWithChildren);
    });
  });

  describe('Filter Type Safety', () => {
    it('should provide type-safe where conditions', async () => {
      // Valid where conditions
      expectAssignable<any>(
        db.select().from(user).where(eq(user.email, 'test@example.com'))
      );

      expectAssignable<any>(
        db.select().from(user).where(and(
          eq(user.email, 'test@example.com'),
          eq(user.name, 'John')
        ))
      );

      // Invalid field references should cause errors
      expectError(
        db.select().from(user).where(eq(user.invalidField, 'value'))
      );

      expectError(
        db.select().from(user).where(eq(user.email, 123)) // Wrong type
      );
    });

    it('should type relation filters correctly', async () => {
      // Filtering by related model fields
      const postsWithAuthorFilter = await db.query.post.findMany({
        where: (post, { eq }) => eq(post.published, true),
        with: {
          author: {
            where: (user, { eq }) => eq(user.email, 'admin@example.com')
          }
        }
      });

      expectType<Array<{
        id: string;
        title: string;
        content: string | null;
        authorId: string;
        published: boolean;
        createdAt: Date;
        updatedAt: Date;
        author: {
          id: string;
          email: string;
          name: string | null;
          createdAt: Date;
          updatedAt: Date;
        } | null;
      }>>(postsWithAuthorFilter);
    });
  });

  describe('Insert/Update Type Safety', () => {
    it('should type insertions correctly', async () => {
      // Valid user insertion
      expectAssignable<any>(
        db.insert(user).values({
          email: 'test@example.com',
          name: 'Test User'
        })
      );

      // Valid post insertion with FK
      expectAssignable<any>(
        db.insert(post).values({
          title: 'Test Post',
          content: 'Content',
          authorId: 'user-123'
        })
      );

      // Invalid insertion should error
      expectError(
        db.insert(user).values({
          email: 123,  // Wrong type
          name: 'Test User'
        })
      );

      expectError(
        db.insert(post).values({
          title: 'Test Post'
          // Missing required authorId
        })
      );
    });

    it('should type updates correctly', async () => {
      // Valid update
      expectAssignable<any>(
        db.update(user)
          .set({ name: 'Updated Name' })
          .where(eq(user.id, 'user-123'))
      );

      // Invalid field in set
      expectError(
        db.update(user)
          .set({ invalidField: 'value' })
          .where(eq(user.id, 'user-123'))
      );

      // Invalid type in set
      expectError(
        db.update(user)
          .set({ email: 123 })
          .where(eq(user.id, 'user-123'))
      );
    });
  });

  describe('Transaction Type Safety', () => {
    it('should maintain types within transactions', async () => {
      const result = await db.transaction(async (tx) => {
        const newUser = await tx.insert(user).values({
          email: 'test@example.com',
          name: 'Test User'
        }).returning();

        const newPost = await tx.insert(post).values({
          title: 'Test Post',
          authorId: newUser[0].id
        }).returning();

        return { user: newUser[0], post: newPost[0] };
      });

      expectType<{
        user: InferSelectModel<typeof user>;
        post: InferSelectModel<typeof post>;
      }>(result);
    });
  });
});